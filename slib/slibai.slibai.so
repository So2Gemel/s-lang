module slibai

// ğŸ§  ØªØµÙ†ÙŠÙ Ø¨Ø³ÙŠØ· Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù‚ÙŠÙ…Ø© Ø±Ù‚Ù…ÙŠØ©
method classify(float score) {
  if (score < 0.3) return "ğŸš« Ø¶Ø¹ÙŠÙ";
  else if (score < 0.7) return "ğŸŸ¡ Ù…ØªÙˆØ³Ø·";
  else return "âœ… Ù‚ÙˆÙŠ";
}

// ğŸ§ª ØªØ¯Ø±ÙŠØ¨ Ù†Ù…ÙˆØ°Ø¬ÙŠ Ø¹Ø¨Ø± Ù…Ø¯Ø®Ù„Ø§Øª
method train(list<float> inputs) {
  list<string> labels = [];
  foreach (x in inputs) {
    labels.append(classify(x));
  }
  return labels;
}

// ğŸ“ˆ ØªØ­Ù„ÙŠÙ„ Ø¥Ø­ØµØ§Ø¦ÙŠ Ù„Ù„ØªØ¯Ø±ÙŠØ¨
method summary(list<float> data) {
  float min = slibmath.min(data);
  float max = slibmath.max(data);
  float avg = slibmath.average(data);
  float dev = slibmath.stddev(data);
  return {
    "min": min,
    "max": max,
    "avg": avg,
    "stddev": dev
  };
}

// ğŸ“š ØªØ­Ù„ÙŠÙ„ Ù†ØµÙŠ Ø£ÙˆÙ„ÙŠ
method analyzeText(string txt) {
  int len = txt.length();
  int words = slibutils.countWords(txt);
  bool alpha = slibutils.isAlpha(txt);
  return {
    "chars": len,
    "words": words,
    "alphaOnly": alpha
  };
}

// ğŸ§  ØªÙ†Ø¨Ø¤ Ø­Ø³Ø¨ sigmoid
method predict(float x) {
  float score = slibmath.sigmoid(x);
  return classify(score);
}

// ğŸ” Ù…Ù‚Ø§Ø±Ù†Ø© Ø¨ÙŠÙ† Ù†Ù…ÙˆØ°Ø¬ÙŠÙ†
method compare(list<float> a, list<float> b) {
  float err = 0;
  for (int i = 0; i < a.length(); i++) {
    err += abs(a[i] - b[i]);
  }
  return err / a.length();
}

// ğŸ“ ØªØ¯Ø±ÙŠØ¨ Ù†Ù…ÙˆØ°Ø¬ÙŠ Ø¨Ù†Ø¸Ø§Ù… Ù…ØµÙ†Ù Ø«Ù†Ø§Ø¦ÙŠ
method binaryTrain(list<float> data) {
  map<string, int> stats = {"positive": 0, "negative": 0};
  foreach (x in data) {
    if (slibmath.sigmoid(x) > 0.5) stats["positive"]++;
    else stats["negative"]++;
  }
  return stats;
}

// ğŸ§© Ù†Ù…ÙˆØ°Ø¬ Ø´Ø¨ÙƒÙŠ ØªØ¬Ø±ÙŠØ¨ÙŠ (ØºÙŠØ± Ø¹ØµØ¨ÙˆÙ†ÙŠ Ø¨Ø¹Ø¯)
class LinearModel {
  float weight = 1.0;
  float bias = 0.0;

  method forward(float x) => x * weight + bias;

  method train(list<float> xs, list<float> ys) {
    float sumW = 0;
    float sumB = 0;
    for (int i = 0; i < xs.length(); i++) {
      sumW += ys[i] / xs[i];
      sumB += ys[i] - (xs[i] * weight);
    }
    weight = sumW / xs.length();
    bias = sumB / xs.length();
  }
}
